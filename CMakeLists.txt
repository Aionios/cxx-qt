# TODO: figure out what the actual hard minimum is
cmake_minimum_required(VERSION 3.16)

project(cxx_example)
set(APP_NAME hello)

# TODO: figure out if RelWithDebInfo is a thing in Rust and fix accordingly
if (CMAKE_BUILD_TYPE STREQUAL "Debug")
    set(CARGO_CMD cargo build)
    set(TARGET_DIR "debug")
else ()
    set(CARGO_CMD cargo build --release)
    set(TARGET_DIR "release")
endif ()

# We list the rust source files that lead to generated C++ files here
# so that CMake is forced to re-run cargo and parse the list it produces
# during the config stage when this list of source files changes.
set(
    RUST_SRC
    lib.rs
)
file(MAKE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/target/cxx-qt")
file(WRITE "${CMAKE_CURRENT_SOURCE_DIR}/target/cxx-qt/rust_sources.txt" "${RUST_SRC}")

# Run cargo during config to ensure the cpp source file list is created
execute_process(
    COMMAND ${CARGO_CMD}
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
)

# Now we can read the list of C++ files that cargo produced
file(STRINGS "${CMAKE_CURRENT_SOURCE_DIR}/target/cxx-qt/cpp_sources.txt" GEN_SOURCES)

# We also want CMake to compile the C++ source files that we have created ourselves
# i.e. those that were not generated by build.rs
set (
    CPP_SOURCES
    src/test.cpp
)

# And specify that we want CMake to build these sources
add_executable(${APP_NAME} ${CPP_SOURCES} ${GEN_SOURCES})
target_include_directories(${APP_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_include_directories(${APP_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/target/cxx-qt/include")

# We also list the .a produced by cargo as a dependency so that cargo gets a
# chance to rebuild the .a every time that a cmake build is run.
# TODO: use correct binary name on windows
set(RUST_PART_LIB "${CMAKE_CURRENT_SOURCE_DIR}/target/${TARGET_DIR}/librust.a")
add_custom_target(
    rustlib
    COMMAND ${CARGO_CMD}
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
)
add_dependencies(${APP_NAME} rustlib)

# The Rust lib also needs to be linked to pthread and dl
# TODO: figure out the equivalent on windows
target_link_libraries(${APP_NAME} ${RUST_PART_LIB} pthread dl)

# Create helper method which adds relevent cargo tests for a given manifest
function(add_test_cargo TEST_NAME_PREFIX MANIFEST_PATH ADD_DOCTESTS)
    # Add cargo as a test
    add_test(NAME ${TEST_NAME_PREFIX}_cargo_tests COMMAND cargo test --all-targets --all-features --manifest-path ${MANIFEST_PATH})
    # Check if we should enable doc tests
    if (${ADD_DOCTESTS} STREQUAL "DOCTESTS_ON")
        # Add cargo docs as a test
        add_test(NAME ${TEST_NAME_PREFIX}_cargo_doc_tests COMMAND cargo test --doc --manifest-path ${MANIFEST_PATH})
    endif()
    # Add clippy as a test
    add_test(NAME ${TEST_NAME_PREFIX}_cargo_clippy COMMAND cargo clippy --all-targets --all-features --manifest-path ${MANIFEST_PATH} -- -D warnings)
    # Add rustfmt as a test
    add_test(NAME ${TEST_NAME_PREFIX}_cargo_fmt COMMAND cargo fmt --manifest-path ${MANIFEST_PATH} -- --check)
endfunction()

# Add cargo tests for all our manifests
#
# Note doctests are not supported on the staticlib in root
add_test_cargo(root "${CMAKE_CURRENT_SOURCE_DIR}/Cargo.toml" DOCTESTS_OFF)
add_test_cargo(clang_format "${CMAKE_CURRENT_SOURCE_DIR}/clang-format/Cargo.toml" DOCTESTS_ON)
add_test_cargo(cxx_qt "${CMAKE_CURRENT_SOURCE_DIR}/cxx-qt/Cargo.toml" DOCTESTS_ON)
add_test_cargo(cxx_qt_gen "${CMAKE_CURRENT_SOURCE_DIR}/cxx-qt-gen/Cargo.toml" DOCTESTS_ON)

# Enable testing
enable_testing()
